{"version":3,"sources":["uid.ts","EditReducer.ts","ExpressionChooser.js","Editor.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["gen32","Math","random","toString","substring","uid","isProgramNode","node","type","isExpressionNode","isUndefinedExpressionNode","isIntegerLiteralNode","isArrayLiteralNode","isStreamReferenceNode","SCHEMA_NODES","Program","fields","expressions","Identifier","name","UndefinedExpression","streamId","identifier","IntegerLiteral","value","ArrayLiteral","items","StreamReference","targetStreamId","SCHEMA_CLASSES","Expression","Any","nodeFromPath","root","path","cur","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err","return","nodeSplitPath","idx","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","seg","slice","Error","equiv","a","b","JSON","stringify","HANDLERS","_ref","subpath","action","length","newIdx","max","min","newExpressionIdx","_ref2","removeIdx","newNode","Object","objectSpread","concat","toConsumableArray","push","genuid","deleteExpression","_ref3","_ref4","_ref5","_ref6","trimmedName","trim","_ref7","editingSelected","_ref8","afterIdx","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","recursiveReducer","state","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","nodeOnPath","selectionPath","nodeInfo","newSelPath","newEditingSelected","handled","indexableNode","_i","_Object$entries","entries","_ref20","_ref17","slicedToArray","fieldName","childNode","recResult","_recResult","n","sp","es","newArr","childNodes","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","arrn","_recResult3","isIdentifierNode","isNode","_i2","_HANDLERS","_ref21","_ref19","nt","acts","hfunc","includes","_nodeSplitPath","_nodeSplitPath2","pathBefore","handlerResult","console","log","_handlerResult","handlerNewNode","handlerNewSubpath","handlerNewEditingSelected","reducer","_recResult4","newRoot","newSelectionPath","initialState","FLOAT_REGEX","ExpressionChooser","dispatch","_useState","useState","_useState2","text","setText","react_default","createElement","className","onChange","e","newText","target","test","Number","onKeyDown","key","stopPropagation","autoFocus","keyMap","MOVE_UP","MOVE_DOWN","MOVE_LEFT","MOVE_RIGHT","ZOOM_IN","ZOOM_OUT","BEGIN_EDIT","INSERT_AFTER","DELETE","NAME","COMMAND_CHARS","DispatchContext","createContext","SelectedNodeContext","useWithSelectedClass","obj","cns","arguments","useContext","EditingSelectedContext","ProgramView","program","map","expression","ExpressionView","IdentifierChooser","initialName","onUpdateName","onEndEdit","NotEditingIdentifierView","ExpressionIdentifierView","selected","IntegerLiteralView","integerLiteral","ArrayLiteralView","arrayLiteral","item","UndefinedExpressionView","undefinedExpression","NotEditingExpressionView","Editor","_useReducer","useReducer","_useReducer2","editorElem","useRef","_useState3","constAutoFocus","useEffect","current","focus","previouslyEditingSelected","handlers","_loop","k","_Object$keys","preventDefault","keys","index_es","only","tagName","toLowerCase","altkey","ctrlKey","metaKey","tabIndex","ref","Provider","App","Editor_Editor","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cf7fa383.chunk.js","sourcesContent":["const gen32 = (): string => Math.random().toString(16).substring(2, 10);\n\nexport default (): string => gen32() + gen32();\n","import genuid from './uid';\n\n// We don't make a discriminated union of specific actions, but maybe we could\ninterface Action {\n  type: string;\n  char?: string;\n  newNode?: Node;\n}\n\ntype StreamID = string;\n\ninterface ProgramNode {\n  type: 'Program';\n  expressions: ExpressionNode[];\n}\nfunction isProgramNode(node: Node): node is ProgramNode {\n  return node.type === 'Program';\n}\n\ninterface IdentifierNode {\n  type: 'Identifier';\n  name: string;\n}\nfunction isIdentifierNode(node: Node): node is IdentifierNode {\n  return node.type === 'Identifier';\n}\n\ntype ExpressionNode = UndefinedExpressionNode | IntegerLiteralNode | ArrayLiteralNode | StreamReferenceNode;\nfunction isExpressionNode(node: Node): node is ExpressionNode {\n  return isUndefinedExpressionNode(node) || isIntegerLiteralNode(node) || isArrayLiteralNode(node)|| isStreamReferenceNode(node);\n}\n\ninterface UndefinedExpressionNode {\n  type: 'UndefinedExpression';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n}\nfunction isUndefinedExpressionNode(node: Node): node is UndefinedExpressionNode {\n  return node.type === 'UndefinedExpression';\n}\n\ninterface IntegerLiteralNode {\n  type: 'IntegerLiteral';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  value: number;\n}\nfunction isIntegerLiteralNode(node: Node): node is IntegerLiteralNode {\n  return node.type === 'IntegerLiteral';\n}\n\ninterface ArrayLiteralNode {\n  type: 'ArrayLiteral';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  items: ExpressionNode[];\n}\nfunction isArrayLiteralNode(node: Node): node is ArrayLiteralNode {\n  return node.type === 'ArrayLiteral';\n}\n\ninterface StreamReferenceNode {\n  type: 'StreamReference',\n  streamId: StreamID,\n  identifier: IdentifierNode | null;\n  targetStreamId: StreamID,\n}\nfunction isStreamReferenceNode(node: Node): node is StreamReferenceNode {\n  return node.type === 'StreamReference';\n}\n\ntype Node = ProgramNode | IdentifierNode | ExpressionNode;\nfunction isNode(node: any): node is Node {\n  return isProgramNode(node) || isIdentifierNode(node) || isExpressionNode(node);\n}\n\ntype Path = (string | number)[];\n\ninterface HandlerArgs {\n  node: Node,\n  subpath: Path,\n  editingSelected: boolean,\n  action: Action;\n}\ntype HandlerResult = (undefined | [Node, Path, boolean]);\ntype Handler = [string, string[], (args: HandlerArgs) => HandlerResult];\n\ninterface State {\n  root: ProgramNode;\n  selectionPath: Path;\n  editingSelected: boolean;\n}\n\nconst SCHEMA_NODES = {\n  Program: {\n    fields: {\n      expressions: {type: 'nodes'},\n    }\n  },\n\n  Identifier: {\n    fields: {\n      name: {type: 'value'},\n    }\n  },\n\n  UndefinedExpression: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n    }\n  },\n\n  IntegerLiteral: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      value: {type: 'value'},\n    }\n  },\n\n  ArrayLiteral: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      items: {type: 'nodes'},\n    }\n  },\n\n  StreamReference: {\n    fields: {\n      streamId: {type: 'uid'},\n      targetStreamId: {type: 'uid'},\n    }\n  },\n};\n\n// TODO: If we want to include other classes in the lists, generate an expansion over the closure\nconst SCHEMA_CLASSES: {[nodeType: string]: string[]} = {\n  Expression: ['UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference'],\n  Any: ['Program', 'Identifier', 'UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference'],\n}\n\nexport function nodeFromPath(root: Node, path: Path): Node {\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n  }\n  return cur;\n}\n\nexport function nodeOnPath(node: Node, root: Node, path: Path): boolean {\n  if (node === root) {\n    return true;\n  }\n\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n    if (node === cur) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function nodeSplitPath(node: Node, root: Node, path: Path): [Path, Path] {\n  let cur: any = root;\n  let idx = 0;\n  for (const seg of path) {\n    if (node === cur) {\n      return [path.slice(0, idx), path.slice(idx)];\n    }\n    cur = cur[seg];\n    idx++;\n  }\n\n  if (node === cur) {\n    return [path.slice(0, idx), path.slice(idx)];\n  } else {\n    throw new Error('node was not in path');\n  }\n}\n\nconst equiv = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\nfunction deleteExpression(node: ProgramNode, removeIdx: number): [ProgramNode, Path, boolean] {\n  // TODO: Handle case where we delete all expressions\n  if (typeof(removeIdx) !== 'number') {\n    throw new Error();\n  }\n  const newNode = {\n    ...node,\n    expressions: [\n      ...node.expressions.slice(0, removeIdx),\n      ...node.expressions.slice(removeIdx+1),\n    ],\n  };\n\n  if (newNode.expressions.length) {\n    let newIdx = removeIdx-1;\n    newIdx = Math.max(newIdx, 0);\n    newIdx = Math.min(newIdx, node.expressions.length-1);\n    return [newNode, ['expressions', newIdx], false];\n  } else {\n    // We've deleted all expressions, so make a single empty one.\n    newNode.expressions.push({\n      type: 'UndefinedExpression',\n      streamId: genuid(),\n      identifier: null,\n    });\n    return [newNode, ['expressions', 0], true];\n  }\n}\n\nconst HANDLERS: Handler[] = [\n  ['Program', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n\n    // NOTE: This assumes that selection is on/in one of the expressions\n    const newExpressionIdx = () => {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      let newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n      newIdx = Math.max(newIdx, 0);\n      newIdx = Math.min(newIdx, node.expressions.length-1);\n      return newIdx;\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      return [node, ['expressions', newExpressionIdx()], false];\n    }\n  }],\n\n  ['Program', ['DELETE'], ({node, subpath}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      return deleteExpression(node, removeIdx);\n    }\n  }],\n\n  ['Expression', ['BEGIN_EDIT'], ({node, subpath}) => {\n    switch (node.type) {\n      case 'IntegerLiteral':\n        return [node, subpath, true];\n\n      case 'UndefinedExpression':\n        return [node, subpath, true];\n\n      case 'ArrayLiteral':\n        // Can't directly edit\n        break;\n\n      default:\n        throw new Error();\n    }\n  }],\n\n  ['Expression', ['BEGIN_EDIT_FRESH'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    return [{\n      type: 'UndefinedExpression',\n      streamId: node.streamId,\n      identifier: node.identifier,\n    }, subpath, true];\n  }],\n\n  ['Expression', ['END_EXPRESSION_EDIT'], ({node, subpath}) => {\n    return [node, subpath, false];\n  }],\n\n  ['Expression', ['END_EXPRESSION_IDENTIFIER_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (!equiv(subpath, ['identifier'])) {\n      throw new Error();\n    }\n    if (!node.identifier) {\n      throw new Error();\n    }\n    const trimmedName = node.identifier.name.trim();\n    return [{\n      ...node,\n      identifier: trimmedName ? {\n        type: 'Identifier',\n        name: trimmedName,\n      } : null,\n    }, [], false];\n  }],\n\n  ['Any', ['UPDATE_NODE'], ({subpath, action, editingSelected}) => {\n    if (!action.newNode) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      return [action.newNode, subpath, editingSelected];\n    }\n  }],\n\n  ['Program', ['INSERT_AFTER'], ({node, subpath}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length >= 2) && (subpath[0] === 'expressions')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ProgramNode = {\n        ...node,\n        expressions: [\n          ...node.expressions.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          },\n          ...node.expressions.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['expressions', afterIdx+1], true];\n    }\n  }],\n\n  /**\n   * NAME on an expression will move to editing identifer.\n   */\n  ['Expression', ['NAME'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (equiv(subpath, [])) {\n      return [{\n        ...node,\n        identifier: node.identifier ? node.identifier : {type: 'Identifier', name: ''},\n      }, ['identifier'], true];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know array is displayed vertically for now\n  ['ArrayLiteral', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (subpath.length === 2) {\n      if ((subpath[0] !== 'items') || (typeof(subpath[1]) !== 'number')) {\n        throw Error();\n      }\n      return [node, [], false];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know it will be in a vertical-list container\n  ['ArrayLiteral', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      // We do a special thing here: If the array is empty, we create a single undefined item.\n      // This gives us a way to add a new element to an empty array.\n      if (node.items.length === 0) {\n        return [{\n          ...node,\n          items: [\n            {\n              type: 'UndefinedExpression',\n              streamId: genuid(),\n              identifier: null,\n            }\n          ],\n        }, ['items', 0], true];\n      } else {\n        return [node, ['items', 0], false];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) || (newIdx >= node.items.length)) {\n        return [node, [], false];\n      } else {\n        return [node, ['items', newIdx], false];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['INSERT_AFTER'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ArrayLiteralNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          },\n          ...node.items.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['items', afterIdx+1], true];\n    }\n  }],\n\n  ['ArrayLiteral', ['DELETE'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if (node.items.length === 0) {\n        throw new Error();\n      }\n\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, removeIdx),\n          ...node.items.slice(removeIdx+1),\n        ],\n      };\n\n      if (newNode.items.length > 0) {\n        let newIdx = removeIdx-1;\n        newIdx = Math.max(newIdx, 0);\n        newIdx = Math.min(newIdx, node.items.length-1);\n        return [newNode, ['items', newIdx], false];\n      } else {\n        return [newNode, [], false];\n      }\n    }\n  }],\n\n  ['Expression', ['CREATE_ARRAY'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    if (subpath.length === 0) {\n      return [{\n        type: 'ArrayLiteral',\n        streamId: node.streamId,\n        identifier: node.identifier,\n        items: [\n          {\n            type: 'UndefinedExpression',\n            identifier: null,\n            streamId: genuid(),\n          }\n        ],\n      }, ['items', 0], true];\n    }\n  }],\n];\n\n/**\n * Returns null or [newNode, newSelectionPath, newTextEdit]\n */\nfunction recursiveReducer(state: State, node: Node, action: Action): (null | [Node, Path, boolean]) {\n  // If this node is not on the selection path, we can short circuit\n  if (!nodeOnPath(node, state.root, state.selectionPath)) {\n    return null;\n  }\n\n  // Build new node, recursing into any child nodes\n  // If nothing has changed, we try to return the original object to allow callers to memoize\n  const nodeInfo = SCHEMA_NODES[node.type];\n  if (!nodeInfo) {\n    throw new Error();\n  }\n  const newNode: any = {\n    type: node.type,\n  };\n  let newSelPath = null;\n  let newEditingSelected = false;\n  let handled = false;\n  const indexableNode = node as {[prop: string]: any}; // to avoid type errors\n  for (const [fieldName, fieldInfo] of Object.entries(nodeInfo.fields)) {\n    switch (fieldInfo.type) {\n      case 'node': {\n        const childNode = indexableNode[fieldName];\n        const recResult = recursiveReducer(state, childNode, action);\n        if (recResult) {\n          if (handled) {\n            throw new Error('already handled');\n          }\n          const [n, sp, es] = recResult;\n          newNode[fieldName] = n;\n          newSelPath = sp;\n          newEditingSelected = es;\n          handled = true;\n        } else {\n          newNode[fieldName] = childNode;\n        }\n        break;\n      }\n\n      case 'nodes': {\n        const newArr = [];\n        const childNodes = indexableNode[fieldName];\n        for (const arrn of childNodes) {\n          const recResult = recursiveReducer(state, arrn, action);\n          if (recResult) {\n            if (handled) {\n              throw new Error('already handled');\n            }\n            const [n, sp, es] = recResult;\n            newArr.push(n);\n            newSelPath = sp;\n            newEditingSelected = es;\n            handled = true;\n          } else {\n            newArr.push(arrn);\n          }\n        }\n        newNode[fieldName] = newArr;\n        break;\n      }\n\n      case 'value':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      case 'uid':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      default:\n        throw new Error();\n    }\n  }\n\n  // If the action has been handled, we can return now\n  if (handled) {\n    if (!isNode(newNode)) {\n      throw new Error();\n    }\n    if (!newSelPath) {\n      throw new Error();\n    }\n    return [newNode, newSelPath, newEditingSelected];\n  }\n\n  // Try any matching handlers\n  for (const [nt, acts, hfunc] of HANDLERS) {\n    const matchingTypes = SCHEMA_CLASSES[nt] ? SCHEMA_CLASSES[nt] : [nt];\n    if (matchingTypes.includes(node.type) && acts.includes(action.type)) {\n      const [pathBefore, pathAfter] = nodeSplitPath(node, state.root, state.selectionPath);\n      const handlerResult = hfunc({\n        node,\n        subpath: pathAfter,\n        editingSelected: state.editingSelected,\n        action,\n      });\n      if (handlerResult) {\n        console.log('handlerResult', handlerResult);\n        const [handlerNewNode, handlerNewSubpath, handlerNewEditingSelected] = handlerResult;\n        return [handlerNewNode, pathBefore.concat(handlerNewSubpath), handlerNewEditingSelected];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function reducer(state: State, action: Action): State {\n  console.log('action', action.type);\n\n/*\n  // Some actions are handled specially\n  if (action.type === 'SET_TEXT') {\n    if (!state.textEdit) {\n      throw new Error();\n    }\n    if (typeof(action.text) !== 'string') {\n      throw new Error();\n    }\n\n    return {\n      ...state,\n      textEdit: {\n        ...state.textEdit,\n        text: action.text,\n      }\n    };\n  }\n*/\n\n  const recResult = recursiveReducer(state, state.root, action);\n  if (recResult) {\n    console.log('handled');\n    const [newRoot, newSelectionPath, newEditingSelected] = recResult;\n    console.log('new selectionPath is', newSelectionPath, 'newEditingSelected is', newEditingSelected);\n\n    if (!isProgramNode(newRoot)) {\n      throw new Error();\n    }\n\n    return {\n      root: newRoot,\n      selectionPath: newSelectionPath,\n      editingSelected: newEditingSelected,\n    };\n  } else {\n    console.log('not handled');\n    return state;\n  }\n}\n\nexport const initialState: State = {\n  root: {\n    type: 'Program',\n    expressions: [\n      {\n        type: 'IntegerLiteral',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'foo',\n        },\n        value: 123,\n      },\n      {\n        type: 'IntegerLiteral',\n        streamId: genuid(),\n        identifier: null,\n        value: 456,\n      },\n      {\n        type: 'IntegerLiteral',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'bar',\n        },\n        value: 789,\n      },\n      {\n        type: 'ArrayLiteral',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'an array literal',\n        },\n        items: [\n          {\n            type: 'IntegerLiteral',\n            streamId: genuid(),\n            identifier: null,\n            value: 123,\n          },\n          {\n            type: 'ArrayLiteral',\n            streamId: genuid(),\n            identifier: {\n              type: 'Identifier',\n              name: 'nice subarray',\n            },\n                items: [\n              {\n                type: 'IntegerLiteral',\n                streamId: genuid(),\n                identifier: null,\n                value: 345,\n              },\n              {\n                type: 'IntegerLiteral',\n                streamId: genuid(),\n                identifier: null,\n                value: 456,\n              },\n            ],\n          },\n          {\n            type: 'IntegerLiteral',\n            streamId: genuid(),\n            identifier: null,\n            value: 234,\n          },\n        ],\n      },\n      {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'quux',\n        },\n      },\n    ]\n  },\n  selectionPath: ['expressions', 0],\n  editingSelected: false,\n};\n","import React, { useState } from 'react';\n\nconst FLOAT_REGEX = /^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n\nexport default function ExpressionChooser({ node, dispatch }) {\n  const [text, setText] = useState(() => {\n    // Initialize text based on existing node\n    switch (node.type) {\n      case 'UndefinedExpression':\n        return '';\n\n      case 'IntegerLiteral':\n        return node.value.toString();\n\n      default:\n        throw new Error();\n    }\n  });\n\n  const onChange = e => {\n    const newText = e.target.value;\n\n    setText(newText);\n\n    if (newText === '[') {\n      dispatch({type: 'END_EXPRESSION_EDIT'});\n      dispatch({type: 'CREATE_ARRAY'});\n    } else if (FLOAT_REGEX.test(newText)) {\n      dispatch({\n        type: 'UPDATE_NODE',\n        newNode: {\n          type: 'IntegerLiteral',\n          streamId: node.streamId,\n          identifier: node.identifier,\n          value: Number(newText),\n        },\n      });\n    } else {\n      dispatch({\n        type: 'UPDATE_NODE',\n        newNode: {\n          type: 'UndefinedExpression',\n          streamId: node.streamId,\n          identifier: node.identifier,\n        },\n      });\n    }\n  };\n\n  const onKeyDown = e => {\n    switch (e.key) {\n      case 'Enter':\n        e.stopPropagation();\n        dispatch({type: 'END_EXPRESSION_EDIT'});\n        break;\n\n      case 'Backspace':\n        if (!e.target.value) {\n          dispatch({type: 'END_EXPRESSION_EDIT'});\n          dispatch({type: 'DELETE'});\n        }\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return <div><input className=\"Editor-text-edit-input\" value={text} onChange={onChange} onKeyDown={onKeyDown} autoFocus /></div>\n}\n","import React, { createContext, useContext, useReducer, useRef, useEffect, useState } from 'react';\nimport { HotKeys, ObserveKeys } from \"react-hotkeys\";\nimport { initialState, reducer, nodeFromPath } from './EditReducer';\nimport ExpressionChooser from './ExpressionChooser';\nimport './Editor.css';\n\nconst keyMap = {\n  MOVE_UP: 'up',\n  MOVE_DOWN: 'down',\n  MOVE_LEFT: 'left',\n  MOVE_RIGHT: 'right',\n\n  ZOOM_IN: 'shift+right',\n  ZOOM_OUT: 'shift+left',\n\n  BEGIN_EDIT: 'enter',\n\n  INSERT_AFTER: [';', ','],\n\n  DELETE: 'backspace',\n  NAME: '=',\n};\n\n// \"Regular\" (printable, basically) characters that are used as commands.\n// We want to handle them as commands even if they happen in an input element,\n// and we don't want them to trigger an edit to begin.\nconst COMMAND_CHARS = [\n  '=',\n  ';',\n  ',',\n];\n\nconst DispatchContext = createContext();\n\nconst SelectedNodeContext = createContext();\nfunction useWithSelectedClass(obj, cns = '') {\n  const selectedNode = useContext(SelectedNodeContext);\n  return (obj === selectedNode) ? (cns + ' Editor-selected') : cns;\n}\n\nconst EditingSelectedContext = createContext();\n\nfunction ProgramView({ program }) {\n  return (\n    <div className=\"Editor-program\">\n      {program.expressions.map((expression) => (\n        <div className=\"Editor-program-expression\" key={expression.streamId}>\n          <ExpressionView expression={expression} />\n        </div>\n      ))}\n    </div>\n  );\n}\n\nfunction IdentifierChooser({ initialName, onUpdateName, onEndEdit }) {\n  const [text, setText] = useState(initialName || '');\n\n  const handleChange = e => {\n    const newText = e.target.value;\n    setText(newText);\n    if (onUpdateName) {\n      onUpdateName(newText);\n    }\n  };\n\n  const handleKeyDown = e => {\n    switch (e.key) {\n      case 'Enter':\n        e.stopPropagation();\n        if (onEndEdit) {\n          onEndEdit();\n        }\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n/*\n        // Commit name\n        const trimmedName = node.identifier.name.trim();\n        if (trimmedName) {\n          return [{\n            ...node,\n            identifier: {\n              type: 'Identifier',\n              name: trimmedName,\n            },\n          }, [], null];\n        } else {\n          // If the name is empty (after trim), get rid of identifier node\n          return [{\n            ...node,\n            identifier: null,\n          }, [], null];\n        }\n*/\n\n  return <div><input className=\"Editor-text-edit-input\" value={text} onChange={handleChange} onKeyDown={handleKeyDown} autoFocus /></div>\n}\n\nfunction NotEditingIdentifierView({ identifier }) {\n  return identifier.name;\n}\n\nfunction ExpressionIdentifierView({ expression }) {\n  const identifier = expression.identifier;\n  const selected = (identifier === useContext(SelectedNodeContext));\n  const editingSelected = useContext(EditingSelectedContext);\n  const dispatch = useContext(DispatchContext);\n\n  const handleUpdateName = (name) => {\n    dispatch({\n      type: 'UPDATE_NODE',\n      newNode: {\n        type: 'Identifier',\n        name,\n      },\n    });\n  };\n\n  const handleEndEdit = () => {\n    dispatch({type: 'END_EXPRESSION_IDENTIFIER_EDIT'});\n  };\n\n  return (\n    <div className={useWithSelectedClass(identifier)}>{(selected && editingSelected)\n      ? <IdentifierChooser initialName={identifier.name} onUpdateName={handleUpdateName} onEndEdit={handleEndEdit} />\n      : <NotEditingIdentifierView identifier={identifier} />\n    }</div>\n  );\n}\n\nfunction IntegerLiteralView({ integerLiteral }) {\n  return <div>{integerLiteral.value}</div>;\n}\n\nfunction ArrayLiteralView({ arrayLiteral }) {\n  return (\n    <div>\n      <div>[</div>\n      <div className=\"Editor-array-items\">\n        {arrayLiteral.items.map(item => (\n          <div className=\"Editor-array-item\" key={item.streamId}><ExpressionView expression={item} /></div>\n        ))}\n      </div>\n      <div>]</div>\n    </div>\n  );\n}\n\nfunction UndefinedExpressionView({ undefinedExpression }) {\n  return <div className=\"Editor-undefined-expression\">&nbsp;</div>;\n}\n\nfunction NotEditingExpressionView({ expression }) {\n  switch (expression.type) {\n    case 'IntegerLiteral':\n      return <IntegerLiteralView integerLiteral={expression} />\n\n    case 'ArrayLiteral':\n      return <ArrayLiteralView arrayLiteral={expression} />\n\n    case 'UndefinedExpression':\n      return <UndefinedExpressionView undefinedExpression={expression} />\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction ExpressionView({ expression }) {\n  const selected = (expression === useContext(SelectedNodeContext));\n  const editingSelected = useContext(EditingSelectedContext);\n  const dispatch = useContext(DispatchContext);\n\n  return (\n    <div className={useWithSelectedClass(expression, 'Editor-expression')}>\n      <div className=\"Editor-expression-main\">\n        {(selected && editingSelected)\n        ? <ExpressionChooser node={expression} dispatch={dispatch} />\n        : <NotEditingExpressionView expression={expression} />\n        }\n      </div>\n      {expression.identifier\n        ? <div className=\"Editor-expression-identifier\"><ExpressionIdentifierView expression={expression} /></div>\n        : null\n      }\n    </div>\n  );\n}\n\nexport default function Editor({ autoFocus }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const editorElem = useRef();\n\n  // Do auto-focus if prop is set\n  const [constAutoFocus] = useState(autoFocus);\n  useEffect(() => {\n    if (constAutoFocus) {\n      // Focus editor after initial render\n      editorElem.current.focus();\n    }\n  }, [constAutoFocus]);\n\n  // Restore focus to editor elem if input box just went away.\n  // NOTE: This is hacky, but don't know better way to handle.\n  const previouslyEditingSelected = useRef(false);\n  useEffect(() => {\n    if (previouslyEditingSelected.current && !state.editingSelected) {\n      editorElem.current.focus();\n    }\n    previouslyEditingSelected.current = state.editingSelected;\n  });\n\n  // TODO: memoize generation of this\n  const handlers = {};\n  for (const k of Object.keys(keyMap)) {\n    handlers[k] = (() => (e) => {\n      e.preventDefault(); // If we attempted to handle this, prevent default (scrolling window, entering character, etc.)\n      dispatch({type: k});\n    })(); // IIFE to bind k\n  }\n\n  const onKeyDown = e => {\n    // TODO: This is not a robust check, but the spec is complicated\n    // (https://www.w3.org/TR/uievents-key/#keys-whitespace)\n    if ((e.target.tagName.toLowerCase() !== 'input') && ([...e.key].length === 1) && !e.altkey && !e.ctrlKey && !e.metaKey && !COMMAND_CHARS.includes(e.key)) {\n      // Interestingly, the key here will still end up going into the input element, which is what we want.\n      dispatch({type: 'BEGIN_EDIT_FRESH'});\n    }\n  };\n\n  return (\n    <HotKeys keyMap={keyMap} handlers={handlers}>\n      <ObserveKeys only={COMMAND_CHARS}>\n        <div className=\"Editor\" onKeyDown={onKeyDown} tabIndex=\"0\" ref={editorElem}>\n          <DispatchContext.Provider value={dispatch}>\n            <SelectedNodeContext.Provider value={nodeFromPath(state.root, state.selectionPath)}>\n              <EditingSelectedContext.Provider value={state.editingSelected}>\n                <ProgramView program={state.root} />\n              </EditingSelectedContext.Provider>\n            </SelectedNodeContext.Provider>\n          </DispatchContext.Provider>\n        </div>\n      </ObserveKeys>\n    </HotKeys>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport Editor from './Editor';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Editor autoFocus={true} />\n      <div>\n        <h2>Notes</h2>\n        <ul>\n          <li><strong>The goal of this is to explore if there's a good way to do keyboard-driven structured code editing that doesn't suck. To not suck, I believe that there must be a very small number of keyboard commands, and they should be rather intuitive/obvious. As a bonus, it would be nice if it behaved similarly to spreadsheets or normal programming editors.</strong></li>\n          <li>Warning: A bunch of shit only half-works.</li>\n          <li>If you don't see a green selection/cursor box, focus the editor.</li>\n          <li>There's no mouse/touch support yet, only keyboard.</li>\n          <li>The AST always stays \"well-formed\", but some bits are allowed to be temporarily unspecified or invalid. The program may still be able to run with unspecified values, and it will be very clear to the user (red boxes) what is invalid/missing.</li>\n          <li>This code doesn't yet \"run\", it's just a fake language for now.</li>\n          <li>Up/down arrows move up and down between expressions and array items.</li>\n          <li>Shift-left (or just left, if unambiguous) \"zooms out\" selection and shift-right (Or just right, if unambiguous) \"zooms in\" selection (into nested structures).</li>\n          <li>Pressing enter on an expression (or sub-expression) will begin editing it. Pressing enter again will stop editing.</li>\n          <li>Instead of pressing enter, you can just start typing letters/numbers and it will begin the edit (overwriting what it there).</li>\n          <li>Pressing the = key on on an expression will move to editing its name.</li>\n          <li>A red box indicates an undefined expression.</li>\n          <li>If you enter an invalid number as an expression, it will ignore it and leave an undefined box.</li>\n          <li>Semicolon or comma (interchangeable) will both add a new assignment or array item below the current one (even during a text edit).</li>\n          <li>Delete will delete expressions, array items, etc.</li>\n          <li>Typeing just [ when editing an expression will create an array literal.</li>\n          <li><strong>TODO</strong> Escape will revert any in-progress edit.</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}