{"version":3,"sources":["uid.ts","EditReducer.ts","Editor.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["gen32","Math","random","toString","substring","uid","isProgramNode","node","type","isAssignmentNode","isIdentifierNode","isExpressionNode","isUndefinedExpressionNode","isIntegerLiteralNode","isArrayLiteralNode","SCHEMA_NODES","Program","fields","assignments","nodeType","Assignment","identifier","expression","Identifier","name","UndefinedExpression","IntegerLiteral","value","ArrayLiteral","items","SCHEMA_CLASSES","Expression","nodeFromPath","root","path","cur","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err","return","nodeSplitPath","idx","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","seg","slice","Error","equiv","a","b","JSON","stringify","deleteAssignment","removeIdx","newNode","Object","objectSpread","concat","toConsumableArray","length","newIdx","max","min","push","genuid","text","updateIdentifier","updateExpression","test","Number","HANDLERS","_ref","subpath","textEdit","_ref2","_ref3","_ref4","_ref5","action","newAssignmentIdx","_ref6","_ref7","nameText","_ref8","_ref9","afterIdx","_ref10","_ref11","char","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","_ref22","recursiveReducer","state","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","nodeOnPath","selectionPath","nodeInfo","newSelPath","newTextEdit","handled","indexableNode","_i","_Object$entries","entries","_ref27","_ref24","slicedToArray","fieldName","childNode","recResult","_recResult","n","sp","te","newArr","childNodes","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","arrn","_recResult3","isNode","_i2","_HANDLERS","_ref28","_ref26","nt","acts","hfunc","includes","_nodeSplitPath","_nodeSplitPath2","pathBefore","handlerResult","console","log","_handlerResult","handlerNewNode","handlerNewSubpath","handlerTextEdit","reducer","_recResult4","newRoot","newSelectionPath","initialState","keyMap","MOVE_UP","MOVE_DOWN","MOVE_LEFT","MOVE_RIGHT","ZOOM_IN","ZOOM_OUT","ENTER","INSERT_AFTER","DELETE","ASSIGN","OPEN_ARRAY","CLOSE_ARRAY","COMMAND_CHARS","DispatchContext","createContext","SelectedNodeContext","useWithSelectedClass","obj","cns","arguments","useContext","TextEditContext","TextEditInput","dispatch","react_default","createElement","className","onChange","e","target","autoFocus","Hole","ProgramView","program","map","assignment","AssignmentView","key","IdentifierView","ExpressionView","NotEditingIdentifierView","selected","IntegerLiteralView","integerLiteral","ArrayLiteralView","arrayLiteral","item","UndefinedExpressionView","undefinedExpression","NotEditingExpressionView","Editor","_useReducer","useReducer","_useReducer2","editorElem","useRef","_useState","useState","constAutoFocus","useEffect","current","focus","previouslyTextEditing","textEditing","handlers","_loop","k","_Object$keys","tagName","toLowerCase","preventDefault","keys","index_es","onKeyDown","altkey","ctrlKey","metaKey","tabIndex","ref","Provider","App","Editor_Editor","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7987c38f.chunk.js","sourcesContent":["const gen32 = (): string => Math.random().toString(16).substring(2, 10);\n\nexport default (): string => gen32() + gen32();\n","import genuid from './uid';\n\n// We don't make a discriminated union of specific actions, but maybe we could\ninterface Action {\n  type: string;\n  text?: string;\n  char?: string;\n}\n\ninterface ProgramNode {\n  type: 'Program';\n  uid: string;\n  assignments: AssignmentNode[];\n}\nfunction isProgramNode(node: Node): node is ProgramNode {\n  return node.type === 'Program';\n}\n\ninterface AssignmentNode {\n  type: 'Assignment';\n  uid: string;\n  identifier: IdentifierNode;\n  expression: ExpressionNode;\n}\nfunction isAssignmentNode(node: Node): node is AssignmentNode {\n  return node.type === 'Assignment';\n}\n\ninterface IdentifierNode {\n  type: 'Identifier';\n  uid: string;\n  name: string | null;\n}\nfunction isIdentifierNode(node: Node): node is IdentifierNode {\n  return node.type === 'Identifier';\n}\n\ntype ExpressionNode = UndefinedExpressionNode | IntegerLiteralNode | ArrayLiteralNode;\nfunction isExpressionNode(node: Node): node is ExpressionNode {\n  return isUndefinedExpressionNode(node) || isIntegerLiteralNode(node)|| isArrayLiteralNode(node);\n}\n\ninterface UndefinedExpressionNode {\n  type: 'UndefinedExpression';\n  uid: string;\n}\nfunction isUndefinedExpressionNode(node: Node): node is UndefinedExpressionNode {\n  return node.type === 'UndefinedExpression';\n}\n\ninterface IntegerLiteralNode {\n  type: 'IntegerLiteral';\n  uid: string;\n  value: number;\n}\nfunction isIntegerLiteralNode(node: Node): node is IntegerLiteralNode {\n  return node.type === 'IntegerLiteral';\n}\n\ninterface ArrayLiteralNode {\n  type: 'ArrayLiteral';\n  uid: string;\n  items: ExpressionNode[];\n}\nfunction isArrayLiteralNode(node: Node): node is ArrayLiteralNode {\n  return node.type === 'ArrayLiteral';\n}\n\ntype Node = ProgramNode | AssignmentNode | IdentifierNode | ExpressionNode;\nfunction isNode(node: any): node is Node {\n  return isProgramNode(node) || isAssignmentNode(node) || isIdentifierNode(node) || isExpressionNode(node);\n}\n\ntype Path = (string | number)[];\n\ninterface TextEdit {\n  text: string;\n}\n\ninterface HandlerArgs {\n  node: Node,\n  subpath: Path,\n  action: Action;\n  textEdit: TextEdit | null;\n}\ntype HandlerResult = (undefined | [Node, Path, TextEdit | null]);\ntype Handler = [string, string[], (args: HandlerArgs) => HandlerResult];\n\ninterface State {\n  root: ProgramNode;\n  selectionPath: Path;\n  textEdit: TextEdit | null;\n}\n\nconst SCHEMA_NODES = {\n  Program: {\n    fields: {\n      uid: {type: 'uid'},\n      assignments: {type: 'nodes', nodeType: 'Assignment'},\n    }\n  },\n\n  Assignment: {\n    fields: {\n      uid: {type: 'uid'},\n      identifier: {type: 'node', nodeType: 'Identifier'},\n      expression: {type: 'node', nodeType: 'Expression'},\n    }\n  },\n\n  Identifier: {\n    fields: {\n      uid: {type: 'uid'},\n      name: {type: 'value'},\n    }\n  },\n\n  UndefinedExpression: {\n    fields: {\n      uid: {type: 'uid'},\n    }\n  },\n\n  IntegerLiteral: {\n    fields: {\n      uid: {type: 'uid'},\n      value: {type: 'value'},\n    }\n  },\n\n  ArrayLiteral: {\n    fields: {\n      uid: {type: 'uid'},\n      items: {type: 'nodes', nodeType: 'Expression'},\n    }\n  },\n};\n\n// TODO: If we want to include other classes in the lists, generate an expansion over the closure\nconst SCHEMA_CLASSES: {[nodeType: string]: string[]} = {\n  Expression: ['UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral'],\n}\n\nexport function nodeFromPath(root: Node, path: Path): Node {\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n  }\n  return cur;\n}\n\nexport function nodeOnPath(node: Node, root: Node, path: Path): boolean {\n  if (node === root) {\n    return true;\n  }\n\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n    if (node === cur) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function nodeSplitPath(node: Node, root: Node, path: Path): [Path, Path] {\n  let cur: any = root;\n  let idx = 0;\n  for (const seg of path) {\n    if (node === cur) {\n      return [path.slice(0, idx), path.slice(idx)];\n    }\n    cur = cur[seg];\n    idx++;\n  }\n\n  if (node === cur) {\n    return [path.slice(0, idx), path.slice(idx)];\n  } else {\n    throw new Error('node was not in path');\n  }\n}\n\nconst equiv = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\nfunction deleteAssignment(node: ProgramNode, removeIdx: number): [ProgramNode, Path, TextEdit | null] {\n  // TODO: Handle case where we delete all assignments\n  if (typeof(removeIdx) !== 'number') {\n    throw new Error();\n  }\n  const newNode = {\n    ...node,\n    assignments: [\n      ...node.assignments.slice(0, removeIdx),\n      ...node.assignments.slice(removeIdx+1),\n    ],\n  };\n\n  if (newNode.assignments.length) {\n    let newIdx = removeIdx-1;\n    newIdx = Math.max(newIdx, 0);\n    newIdx = Math.min(newIdx, node.assignments.length-1);\n    return [newNode, ['assignments', newIdx], null];\n  } else {\n    // We've deleted all assignments, so make a single empty one.\n    newNode.assignments.push({\n      type: 'Assignment',\n      uid: genuid(),\n      identifier: {\n        type: 'Identifier',\n        uid: genuid(),\n        name: null,\n      },\n      expression: {\n        type: 'UndefinedExpression',\n        uid: genuid(),\n      }\n    });\n    return [newNode, ['assignments', 0, 'identifier'], {text: ''}];\n  }\n}\n\nfunction updateIdentifier(node: IdentifierNode, text: string): IdentifierNode {\n  return {\n    ...node,\n    name: text ? text : null, // TODO: ensure that it's valid?\n  };\n}\n\nfunction updateExpression(node: ExpressionNode, text: string): HandlerResult {\n  const FLOAT_REGEX = /^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n\n  if (FLOAT_REGEX.test(text)) {\n    return [{\n      type: 'IntegerLiteral',\n      uid: genuid(),\n      value: Number(text),\n    }, [], {text}];\n  } else {\n    return [{\n      type: 'UndefinedExpression',\n      uid: genuid(),\n    }, [], {text}];\n  }\n}\n\nconst HANDLERS: Handler[] = [\n  ['Assignment', ['MOVE_LEFT'], ({node, subpath, textEdit}) => {\n    if (textEdit) {\n      return;\n    }\n    if (equiv(subpath, ['expression'])) {\n      return [node, ['identifier'], null];\n    }\n    if (equiv(subpath, ['identifier'])) { // NOTE: Behave like ZOOM_OUT since unambiguous\n      return [node, [], null];\n    }\n  }],\n\n  ['Assignment', ['MOVE_RIGHT'], ({node, subpath, textEdit}) => {\n    if (textEdit) {\n      return;\n    }\n    if (equiv(subpath, ['identifier'])) {\n      return [node, ['expression'], null];\n    }\n    if (equiv(subpath, [])) { // NOTE: Behave like ZOOM_IN since unambiguous\n      return [node, ['identifier'], null];\n    }\n  }],\n\n  ['Assignment', ['ZOOM_IN'], ({node, subpath, textEdit}) => {\n    if (textEdit) {\n      return;\n    }\n    if (equiv(subpath, [])) {\n      return [node, ['identifier'], null];\n    }\n  }],\n\n  ['Assignment', ['ZOOM_OUT'], ({node, subpath, textEdit}) => {\n    if (textEdit) {\n      return;\n    }\n    if (equiv(subpath, ['identifier']) || equiv(subpath, ['expression'])) {\n      return [node, [], null];\n    }\n  }],\n\n  ['Program', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, textEdit, action}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n\n    if (textEdit) {\n      return;\n    }\n\n    // NOTE: This assumes that selection is on/in one of the assignments\n    const newAssignmentIdx = () => {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      let newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n      newIdx = Math.max(newIdx, 0);\n      newIdx = Math.min(newIdx, node.assignments.length-1);\n      return newIdx;\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'assignments')) {\n      return [node, ['assignments', newAssignmentIdx()], null];\n    } else if ((subpath.length === 3) && (subpath[0] === 'assignments')) {\n      return [node, ['assignments', newAssignmentIdx(), subpath[2]], null];\n    }\n  }],\n\n  ['Program', ['DELETE'], ({node, subpath, textEdit}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'assignments')) {\n      if (textEdit) {\n        throw new Error();\n      }\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      return deleteAssignment(node, removeIdx);\n    }\n  }],\n\n  ['Identifier', ['ENTER'], ({node, subpath, textEdit}) => {\n    if (!isIdentifierNode(node)) {\n      throw new Error();\n    }\n    if (textEdit) {\n      return [node, subpath, null];\n    } else {\n      const nameText = node.name || '';\n      return [updateIdentifier(node, nameText), subpath, {text: nameText}];\n    }\n  }],\n\n  ['Expression', ['ENTER'], ({node, subpath, textEdit}) => {\n    if (textEdit) {\n      return [node, subpath, null];\n    } else {\n      // Initialize the input\n      switch (node.type) {\n        case 'IntegerLiteral':\n         return updateExpression(node, node.value.toString());\n\n        case 'UndefinedExpression':\n          return updateExpression(node, '');\n\n        case 'ArrayLiteral':\n          // Can't directly edit\n          break;\n\n        default:\n          throw new Error();\n      }\n    }\n  }],\n\n  ['Program', ['INSERT_AFTER'], ({node, subpath, textEdit}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length >= 2) && (subpath[0] === 'assignments')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ProgramNode = {\n        ...node,\n        assignments: [\n          ...node.assignments.slice(0, afterIdx+1),\n          {\n            type: 'Assignment',\n            uid: genuid(),\n            identifier: {\n              type: 'Identifier',\n              uid: genuid(),\n              name: null,\n            },\n            expression: {\n              type: 'UndefinedExpression',\n              uid: genuid(),\n            }\n          },\n          ...node.assignments.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['assignments', afterIdx+1, 'identifier'], {text: ''}];\n    }\n  }],\n\n  /**\n   * DELETE when editing the LHS of assignment will delete the assignment, if the input box is empty and the RHS is undefined.\n   * This is mainly to allow us to easily \"undo\" adding a new assignment by just hitting DELETE.\n   */\n  ['Program', ['DELETE'], ({node, subpath, textEdit}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 3) && (subpath[0] === 'assignments') && (subpath[2] === 'identifier') && textEdit && (textEdit.text === '')) {\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      if (node.assignments[removeIdx].expression.type === 'UndefinedExpression') {\n        if (typeof(removeIdx) !== 'number') {\n          throw new Error();\n        }\n        return deleteAssignment(node, removeIdx);\n      }\n    }\n  }],\n\n  /**\n   * Typing a character on an identifier jumps straight into editing it (overwriting)\n   */\n  ['Identifier', ['CHAR'], ({node, subpath, textEdit, action}) => {\n    if (!isIdentifierNode(node)) {\n      throw new Error();\n    }\n    if (textEdit || subpath.length || !action.char) {\n      throw new Error();\n    }\n    // Space is not a \"command character\", but I don't think we want it to trigger the start of editing\n    if (action.char !== ' ') {\n      return [updateIdentifier(node, action.char), subpath, {text: action.char}];\n    }\n  }],\n\n  /**\n   * Typing a character on an expression jumps straight into editing it (overwriting)\n   */\n  ['Expression', ['CHAR'], ({node, subpath, textEdit, action}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (textEdit || subpath.length || !action.char) {\n      throw new Error();\n    }\n    // Space is not a \"command character\", but I don't think we want it to trigger the start of editing\n    if (action.char !== ' ') {\n      return updateExpression(node, action.char);\n    }\n  }],\n\n  /**\n   * ASSIGN on an assignment will move to editing the RHS in many cases.\n   */\n  ['Assignment', ['ASSIGN'], ({node, subpath, textEdit}) => {\n    if (!isAssignmentNode(node)) {\n      throw new Error();\n    }\n    if ((!textEdit && (equiv(subpath, []) || equiv(subpath, ['identifier']) || equiv(subpath, ['expression']))) ||\n    (textEdit && equiv(subpath, ['identifier']))) {\n      return [{\n        ...node,\n        expression: {\n          type: 'UndefinedExpression',\n          uid: genuid(),\n        },\n      }, ['expression'], {text: ''}];\n    }\n  }],\n\n  ['Identifier', ['SET_TEXT'], ({node, subpath, textEdit, action}) => {\n    if (!textEdit) {\n      throw new Error();\n    }\n    if (typeof(action.text) !== 'string') {\n      throw new Error();\n    }\n    if (subpath.length !== 0) {\n      throw new Error();\n    }\n    if (!isIdentifierNode(node)) {\n      throw new Error();\n    }\n\n    return [updateIdentifier(node, action.text), subpath, {text: action.text}];\n  }],\n\n  ['Expression', ['SET_TEXT'], ({node, subpath, textEdit, action}) => {\n    if (!textEdit) {\n      throw new Error();\n    }\n    if (typeof(action.text) !== 'string') {\n      throw new Error();\n    }\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    return updateExpression(node, action.text);\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know array is displayed vertically for now\n  ['ArrayLiteral', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath, textEdit}) => {\n    if (textEdit) {\n      return;\n    }\n    if (subpath.length === 2) {\n      if ((subpath[0] !== 'items') || (typeof(subpath[1]) !== 'number')) {\n        throw Error();\n      }\n      return [node, [], null];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know it will be in a vertical-list container\n  ['ArrayLiteral', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath, textEdit}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (textEdit) {\n      return;\n    }\n    if (subpath.length === 0) {\n      // We do a special thing here: If the array is empty, we create a single undefined item.\n      // This gives us a way to add a new element to an empty array.\n      if (node.items.length === 0) {\n        return [{\n          ...node,\n          items: [\n            {\n              type: 'UndefinedExpression',\n              uid: genuid(),\n            }\n          ],\n        }, ['items', 0], null];\n      } else {\n        return [node, ['items', 0], null];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, textEdit, action}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n\n    if (textEdit) {\n      return;\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) || (newIdx >= node.items.length)) {\n        return [node, [], null];\n      } else {\n        return [node, ['items', newIdx], null];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['INSERT_AFTER'], ({node, subpath, textEdit}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ArrayLiteralNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            uid: genuid(),\n          },\n          ...node.items.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['items', afterIdx+1], {text: ''}];\n    }\n  }],\n\n  ['ArrayLiteral', ['DELETE'], ({node, subpath, textEdit}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if (node.items.length === 0) {\n        throw new Error();\n      }\n\n      // Selection is on an item\n      if (node.items.length === 1) {\n        // There is exactly one item\n        if (textEdit) {\n          // The single item is being edited, text edit is empty\n          if (textEdit.text === '') {\n            return [{\n              type: 'UndefinedExpression',\n              uid: genuid(),\n            }, [], {text: ''}];\n          }\n        } else {\n          // The single item is not being edited\n          return [{\n            ...node,\n            items: [],\n          }, [], null];\n        }\n      } else {\n        // There is more than one item\n        if (!textEdit || (textEdit.text === '')) {\n          // We're not editing, or we are editing but text is empty, so we will delete this item\n          const removeIdx = subpath[1];\n          if (typeof(removeIdx) !== 'number') {\n            throw new Error();\n          }\n          const newNode = {\n            ...node,\n            items: [\n              ...node.items.slice(0, removeIdx),\n              ...node.items.slice(removeIdx+1),\n            ],\n          };\n\n          let newIdx = removeIdx-1;\n          newIdx = Math.max(newIdx, 0);\n          newIdx = Math.min(newIdx, node.items.length-1);\n          return [newNode, ['items', newIdx], null];\n        }\n      }\n    }\n  }],\n\n  ['Expression', ['OPEN_ARRAY'], ({node, subpath, textEdit}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 0) && (!textEdit || (textEdit.text === ''))) {\n      return [{\n        type: 'ArrayLiteral',\n        uid: genuid(),\n        items: [\n          {\n            type: 'UndefinedExpression',\n            uid: genuid(),\n          }\n        ],\n      }, ['items', 0], {text: ''}];\n    }\n  }],\n\n  ['ArrayLiteral', ['CLOSE_ARRAY'], ({node, subpath, textEdit}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'items') && textEdit) {\n      const idx = subpath[1];\n      if (typeof(idx) !== 'number') {\n        throw new Error();\n      }\n      if (idx === (node.items.length-1)) {\n        // Editing the last item\n        if (textEdit.text === '') {\n          // Delete (empty) node we were editing, go back to to array\n          return [{\n            ...node,\n            items: node.items.slice(0, idx),\n          }, [], null];\n        } else {\n          // Finish edit, go back to to array\n          return [node, [], null];\n        }\n      }\n    }\n  }],\n];\n\n/**\n * Returns null or [newNode, newSelectionPath, newTextEdit]\n */\nfunction recursiveReducer(state: State, node: Node, action: Action): (null | [Node, Path, TextEdit | null]) {\n  // If this node is not on the selection path, we can short circuit\n  if (!nodeOnPath(node, state.root, state.selectionPath)) {\n    return null;\n  }\n\n  // Build new node, recursing into any child nodes\n  // If nothing has changed, we try to return the original object to allow callers to memoize\n  const nodeInfo = SCHEMA_NODES[node.type];\n  if (!nodeInfo) {\n    throw new Error();\n  }\n  const newNode: any = {\n    type: node.type,\n  };\n  let newSelPath = null;\n  let newTextEdit = null;\n  let handled = false;\n  const indexableNode = node as {[prop: string]: any}; // to avoid type errors\n  for (const [fieldName, fieldInfo] of Object.entries(nodeInfo.fields)) {\n    switch (fieldInfo.type) {\n      case 'node': {\n        const childNode = indexableNode[fieldName];\n        const recResult = recursiveReducer(state, childNode, action);\n        if (recResult) {\n          if (handled) {\n            throw new Error('already handled');\n          }\n          const [n, sp, te] = recResult;\n          newNode[fieldName] = n;\n          newSelPath = sp;\n          newTextEdit = te;\n          handled = true;\n        } else {\n          newNode[fieldName] = childNode;\n        }\n        break;\n      }\n\n      case 'nodes': {\n        const newArr = [];\n        const childNodes = indexableNode[fieldName];\n        for (const arrn of childNodes) {\n          const recResult = recursiveReducer(state, arrn, action);\n          if (recResult) {\n            if (handled) {\n              throw new Error('already handled');\n            }\n            const [n, sp, te] = recResult;\n            newArr.push(n);\n            newSelPath = sp;\n            newTextEdit = te;\n            handled = true;\n          } else {\n            newArr.push(arrn);\n          }\n        }\n        newNode[fieldName] = newArr;\n        break;\n      }\n\n      case 'value':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      case 'uid':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      default:\n        throw new Error();\n    }\n  }\n\n  // If the action has been handled, we can return now\n  if (handled) {\n    if (!isNode(newNode)) {\n      throw new Error();\n    }\n    if (!newSelPath) {\n      throw new Error();\n    }\n    return [newNode, newSelPath, newTextEdit];\n  }\n\n  // Try any matching handlers\n  for (const [nt, acts, hfunc] of HANDLERS) {\n    const matchingTypes = SCHEMA_CLASSES[nt] ? SCHEMA_CLASSES[nt] : [nt];\n    if (matchingTypes.includes(node.type) && acts.includes(action.type)) {\n      const [pathBefore, pathAfter] = nodeSplitPath(node, state.root, state.selectionPath);\n      const handlerResult = hfunc({\n        node,\n        subpath: pathAfter,\n        action,\n        textEdit: state.textEdit,\n      });\n      if (handlerResult) {\n        console.log('handlerResult', handlerResult);\n        const [handlerNewNode, handlerNewSubpath, handlerTextEdit] = handlerResult;\n        return [handlerNewNode, pathBefore.concat(handlerNewSubpath), handlerTextEdit];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function reducer(state: State, action: Action): State {\n  console.log('action', action.type);\n\n/*\n  // Some actions are handled specially\n  if (action.type === 'SET_TEXT') {\n    if (!state.textEdit) {\n      throw new Error();\n    }\n    if (typeof(action.text) !== 'string') {\n      throw new Error();\n    }\n\n    return {\n      ...state,\n      textEdit: {\n        ...state.textEdit,\n        text: action.text,\n      }\n    };\n  }\n*/\n\n  const recResult = recursiveReducer(state, state.root, action);\n  if (recResult) {\n    console.log('handled');\n    const [newRoot, newSelectionPath, newTextEdit] = recResult;\n    console.log('new selectionPath is', newSelectionPath, 'textEdit is', newTextEdit);\n\n    if (!isProgramNode(newRoot)) {\n      throw new Error();\n    }\n\n    return {\n      root: newRoot,\n      selectionPath: newSelectionPath,\n      textEdit: newTextEdit,\n    };\n  } else {\n    console.log('not handled');\n    return state;\n  }\n}\n\nexport const initialState: State = {\n  // root: {\n  //   type: 'Program',\n  //   assignments: [],\n  // },\n  root: {\n    type: 'Program',\n    uid: genuid(),\n    assignments: [\n      {\n        type: 'Assignment',\n        uid: genuid(),\n        identifier: {\n          type: 'Identifier',\n          uid: genuid(),\n          name: 'foo',\n        },\n        expression: {\n          type: 'IntegerLiteral',\n          uid: genuid(),\n          value: 123,\n        }\n      },\n      {\n        type: 'Assignment',\n        uid: genuid(),\n        identifier: {\n          type: 'Identifier',\n          uid: genuid(),\n          name: 'bar',\n        },\n        expression: {\n          type: 'IntegerLiteral',\n          uid: genuid(),\n          value: 456,\n        }\n      },\n      {\n        type: 'Assignment',\n        uid: genuid(),\n        identifier: {\n          type: 'Identifier',\n          uid: genuid(),\n          name: 'baz',\n        },\n        expression: {\n          type: 'IntegerLiteral',\n          uid: genuid(),\n          value: 789,\n        }\n      },\n      {\n        type: 'Assignment',\n        uid: genuid(),\n        identifier: {\n          type: 'Identifier',\n          uid: genuid(),\n          name: null,\n        },\n        expression: {\n          type: 'IntegerLiteral',\n          uid: genuid(),\n          value: 4321,\n        }\n      },\n      {\n        type: 'Assignment',\n        uid: genuid(),\n        identifier: {\n          type: 'Identifier',\n          uid: genuid(),\n          name: 'blap',\n        },\n        expression: {\n          type: 'ArrayLiteral',\n          uid: genuid(),\n          items: [\n            {\n              type: 'IntegerLiteral',\n              uid: genuid(),\n              value: 123,\n            },\n            {\n              type: 'ArrayLiteral',\n              uid: genuid(),\n              items: [\n                {\n                  type: 'IntegerLiteral',\n                  uid: genuid(),\n                  value: 345,\n                },\n                {\n                  type: 'IntegerLiteral',\n                  uid: genuid(),\n                  value: 456,\n                },\n              ],\n            },\n            {\n              type: 'IntegerLiteral',\n              uid: genuid(),\n              value: 234,\n            },\n          ],\n        }\n      },\n      {\n        type: 'Assignment',\n        uid: genuid(),\n        identifier: {\n          type: 'Identifier',\n          uid: genuid(),\n          name: 'quux',\n        },\n        expression: {\n          type: 'UndefinedExpression',\n          uid: genuid(),\n        }\n      },\n    ]\n  },\n  selectionPath: ['assignments', 0, 'identifier'],\n  textEdit: null,\n};\n","import React, { createContext, useContext, useReducer, useRef, useEffect, useState } from 'react';\nimport { HotKeys, ObserveKeys } from \"react-hotkeys\";\nimport { initialState, reducer, nodeFromPath } from './EditReducer';\nimport './Editor.css';\n\nconst keyMap = {\n  MOVE_UP: 'up',\n  MOVE_DOWN: 'down',\n  MOVE_LEFT: 'left',\n  MOVE_RIGHT: 'right',\n\n  ZOOM_IN: 'shift+right',\n  ZOOM_OUT: 'shift+left',\n\n  ENTER: 'enter', // could the command be TOGGLE_EDIT?\n\n  INSERT_AFTER: [';', ','],\n\n  DELETE: 'backspace',\n  ASSIGN: '=',\n  OPEN_ARRAY: '[',\n  CLOSE_ARRAY: ']',\n\n/*\n  CANCEL_EDIT: 'escape',\n*/\n};\n\n// \"Regular\" (printable, basically) characters that are used as commands\nconst COMMAND_CHARS = [\n  '=',\n  ';',\n  ',',\n  '[',\n  ']',\n];\n\nconst DispatchContext = createContext();\n\nconst SelectedNodeContext = createContext();\nfunction useWithSelectedClass(obj, cns = '') {\n  const selectedNode = useContext(SelectedNodeContext);\n  return (obj === selectedNode) ? (cns + ' Editor-selected') : cns;\n}\n\nconst TextEditContext = createContext();\n\nfunction TextEditInput() {\n  const dispatch = useContext(DispatchContext);\n  const textEdit = useContext(TextEditContext);\n\n  const onChange = e => {\n    dispatch({\n      type: 'SET_TEXT',\n      text: e.target.value,\n    });\n  };\n\n  return <div><input className=\"Editor-text-edit-input Editor-selected\" value={textEdit.text} onChange={onChange} autoFocus /></div>\n}\n\nfunction Hole() {\n  return <div className=\"Editor-hole\">&nbsp;</div>\n}\n\nfunction ProgramView({ program }) {\n  return (\n    <div className=\"Editor-program\">\n      {program.assignments.map((assignment) => (\n        <AssignmentView assignment={assignment} key={assignment.uid} />\n      ))}\n    </div>\n  );\n}\n\nfunction AssignmentView({ assignment }) {\n  return (\n    <div className={useWithSelectedClass(assignment, 'Editor-assignment')}>\n      <IdentifierView identifier={assignment.identifier} />\n      <div>&nbsp;=&nbsp;</div>\n      <ExpressionView expression={assignment.expression} />\n    </div>\n  );\n}\n\nfunction NotEditingIdentifierView({ identifier }) {\n  return (\n    <div className={useWithSelectedClass(identifier)}>\n      {(typeof identifier.name === 'string')\n        ? identifier.name\n        : <Hole />\n      }\n    </div>\n  );\n}\n\nfunction IdentifierView({ identifier }) {\n  const selected = (identifier === useContext(SelectedNodeContext));\n  const textEdit = useContext(TextEditContext);\n  if (selected && textEdit) {\n    return <TextEditInput />\n  } else {\n    return <NotEditingIdentifierView identifier={identifier} />\n  }\n}\n\nfunction IntegerLiteralView({ integerLiteral }) {\n  return <div className={useWithSelectedClass(integerLiteral)}>{integerLiteral.value}</div>;\n}\n\nfunction ArrayLiteralView({ arrayLiteral }) {\n  return (\n    <div className={useWithSelectedClass(arrayLiteral)}>\n      <div>[</div>\n      <div className=\"Editor-array-items\">\n        {arrayLiteral.items.map(item => (\n          <div className=\"Editor-array-item\" key={item.uid}><ExpressionView expression={item} /></div>\n        ))}\n      </div>\n      <div>]</div>\n    </div>\n  );\n}\n\nfunction UndefinedExpressionView({ undefinedExpression }) {\n  return <div className={useWithSelectedClass(undefinedExpression)}><Hole /></div>;\n}\n\nfunction NotEditingExpressionView({ expression }) {\n  switch (expression.type) {\n    case 'IntegerLiteral':\n      return <IntegerLiteralView integerLiteral={expression} />\n\n    case 'ArrayLiteral':\n      return <ArrayLiteralView arrayLiteral={expression} />\n\n    case 'UndefinedExpression':\n      return <UndefinedExpressionView undefinedExpression={expression} />\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction ExpressionView({ expression }) {\n  const selected = (expression === useContext(SelectedNodeContext));\n  const textEdit = useContext(TextEditContext);\n\n  if (selected && textEdit) {\n    return <TextEditInput />\n  } else {\n    return <NotEditingExpressionView expression={expression} />\n  }\n}\n\nexport default function Editor({ autoFocus }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const editorElem = useRef();\n\n  // Do auto-focus if prop is set\n  const [constAutoFocus] = useState(autoFocus);\n  useEffect(() => {\n    if (constAutoFocus) {\n      // Focus editor after initial render\n      editorElem.current.focus();\n    }\n  }, [constAutoFocus]);\n\n  // Restore focus to editor elem if input box just went away.\n  // NOTE: This is hacky, but don't know better way to handle.\n  const previouslyTextEditing = useRef(false);\n  useEffect(() => {\n    const textEditing = !!state.textEdit;\n    if (previouslyTextEditing.current && !textEditing) {\n      editorElem.current.focus();\n    }\n    previouslyTextEditing.current = textEditing;\n  });\n\n  // TODO: memoize generation of this\n  const handlers = {};\n  for (const k of Object.keys(keyMap)) {\n    handlers[k] = (() => (e) => {\n      if ((e.target.tagName.toLowerCase() !== 'input') || (COMMAND_CHARS.includes(e.key))) {\n        // NOTE: This is important, otherwise keys like '=' will go into the input element\n        e.preventDefault();\n      }\n      dispatch({type: k});\n    })(); // IIFE to bind k\n  }\n\n  const onKeyDown = e => {\n    if (e.target.tagName.toLowerCase() === 'input') {\n      // Ignore if this came from an input box\n      return;\n    }\n    // TODO: This is not a robust check, but the spec is complicated\n    // (https://www.w3.org/TR/uievents-key/#keys-whitespace)\n    if (([...e.key].length === 1) && !e.altkey && !e.ctrlKey && !e.metaKey && !COMMAND_CHARS.includes(e.key)) {\n      e.preventDefault(); // If we generate a CHAR action, then don't also allow default\n      dispatch({\n        type: 'CHAR',\n        char: e.key,\n      });\n    }\n  };\n\n  return (\n    <HotKeys keyMap={keyMap} handlers={handlers}>\n      <ObserveKeys>\n        <div className=\"Editor\" onKeyDown={onKeyDown} tabIndex=\"0\" ref={editorElem}>\n          <DispatchContext.Provider value={dispatch}>\n            <SelectedNodeContext.Provider value={nodeFromPath(state.root, state.selectionPath)}>\n              <TextEditContext.Provider value={state.textEdit}>\n                <ProgramView program={state.root} />\n              </TextEditContext.Provider>\n            </SelectedNodeContext.Provider>\n          </DispatchContext.Provider>\n        </div>\n      </ObserveKeys>\n    </HotKeys>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport Editor from './Editor';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Editor autoFocus={true} />\n      <div>\n        <h2>Notes</h2>\n        <ul>\n          <li><strong>The goal of this is to explore if there's a good way to do keyboard-driven structured code editing that doesn't suck. To not suck, I believe that there must be a very small number of keyboard commands, and they should be rather intuitive/obvious. As a bonus, it would be nice if it behaved similarly to spreadsheets or normal programming editors.</strong></li>\n          <li>Warning: A bunch of shit only half-works.</li>\n          <li>If you don't see a green selection/cursor box, focus the editor.</li>\n          <li>There's no mouse/touch support yet, only keyboard.</li>\n          <li>The AST always stays \"well-formed\", but some bits are allowed to be temporarily unspecified or invalid. The program may still be able to run with unspecified values, and it will be very clear to the user (red boxes) what is invalid/missing.</li>\n          <li>This code doesn't yet \"run\", it's just a fake language for now.</li>\n          <li>Up/down arrows move up and down between assignments and array items.</li>\n          <li>Shift-left (or just left, if unambiguous) \"zooms out\" selection and shift-right (Or just right, if unambiguous) \"zooms in\" selection (into nested structures).</li>\n          <li>If LHS of an assignment is selected, left arrow moves \"out\" to select the entire assignment.</li>\n          <li>Pressing enter on an identifier or number will begin editing it. Pressing enter again will stop editing.</li>\n          <li>Instead of pressing enter, you can just start typing letters/numbers and it will begin the edit (overwriting what it there).</li>\n          <li>Pressing the = key on the \"top levels\" of an assignment will beging editing the RHS.</li>\n          <li>A red box indicates an undefined identifer or expression.</li>\n          <li>If you enter an invalid number as an expression, it will ignore it and leave an undefined box.</li>\n          <li>Semicolon or comma (interchangeable) will both add a new assignment or array item below the current one (even during a text edit).</li>\n          <li>When an entire assignment is selected, delete will delete it.</li>\n          <li>Pressing [ will create an array literal. Pressing ] when editing the last item is a shortcut to \"close\" the array.</li>\n          <li><strong>TODO</strong> Allow creating array literals.</li>\n          <li><strong>TODO</strong> Allow deleting array items.</li>\n          <li><strong>TODO</strong> Validate LHS identifiers.</li>\n          <li><strong>TODO</strong> Escape will revert any in-progress edit.</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}